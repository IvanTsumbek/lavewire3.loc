Правила:
Свойства должны быть публичными. Типизация по усмотрению разработчика
У вьюхи может быть только один корневой контейнер (любой)
В модальных окнах не модальное окно помещаем в компонент, а компонент в него!!!!!!!!


@livewire('counter')                            подключение компонента (контроллера)
<livewire:counter/>                             аналог подключения компонента
<x-sort-arrows/>                                подключение вида
php artisan make:component sort-arrows --view   создание только вида

<input type="text" wire:model.live='name'>      свойство, .live обновляет его сразу
<livewire:user.userlist lastname="Doe"/>        передача данных в свойство компонента с блейда
<livewire:user.userlist :title="$title"/>       если переменная объявлена в блейде. Но с экраном тоже работает
<livewire:user.userlist :$second_title/>             ---analog
@livewire('user.user-list', ['title' => $title,])    ---analog
public function mount(){}                            ---с компонента

<button wire:click="increment">+</button>                                      вызываем метод increment
<form wire:submit='save'>                                                      отправка формы (на кнопке тоже желательно type="submit")
<input type="text" wire:model='username' wire:keydown.shift.enter='addUser'>   кроме клика еще и клавиши

<li  wire:key="{{$user->id}}">                                                 для циклов, чтоб не произошел сбой
<div wire:loading wire:target='addUser'>Loading</div>                          для отображения скрытых элементов во время действия (для форм, кнопок). Но таргетировать можно только свои методы
<button wire:click="$refresh" class="btn btn-success mb-2">Refresh</button>   обновление компонента без перезагрузки страницы
.throttle.3000ms                                                               для задержки. Блокает элемент на это время
.once                                                                          экшн срабатывает 1 раз
.debounce.3000ms                                                               для задержки. Срабатывает элемент через это время
<a href="#" wire:click.prevent="deleteUser({{$user->id}})">Delete</a></li>     .prevent отменяет дефолтное поведение
wire:confirm="Are you sure?"                                                   подтверждение (удобно для удаления)
wire:transition                                                                анимация элемента (работает только с одним элементом)


Валидация используя bootstrap
<div class="mb-3">
<input type="email" class="form-control @error('email') is-invalid @enderror" wire:model='email' placeholder="Email">
@error('email')
<div class="invalid-feedback"> {{ $message }} </div>
@enderror
</div>
php artisan lang:publish                                                       создается в корне папка с выводами ошибок. Мы можем их переделать. В ключе можем поменять локаль и скачать ошибки на другом языке

Простой способ валидации
#[Validate('required|min:2|max:30')]
public string $name;

#[Validate('required', message:'Поле обязательно')]                            вариант со своими сообщениями
#[Validate('min:2', message:'Минимум 2 буквы')]
public string $name;
#[Validate('min:2', as:'Имя')]                                                 алиас для поля

protected function rules(): array                                              можно вынести правила и в метод rules a сообщения в messages
{ return [
                    'name' => 'required|min:2|max:30',
                    'email' => 'required|email|max:30',
                    'password' => 'required|min:6',];}
wire:model.live                                                                в режиме реального времени, удобно для валидации
wire:model.blur                                                                в режиме реального времени, но только если курсор переключили на другое поле, удобно для валидации

php artisan livewire:form UserForm                                             вынос свойств и логики в отдельную форму.Обращение к свойствам wire:model='form.name'. В компоненте создаем объект public UserForm $form;

$this->dispatch('user-created', $user);                                        запускаем событие, можем передать даже объект
#[On('user-created')]                                                          вешаем на любой метод + вьюха сама перерендерится, даже если метод пустой

use WithPagination;  {{ $users->links()}}                                     компонент и вьюха
{{ $users->links(data:['scrollTo' => false])}}                                отключаем скролл
php artisan livewire:publish --config                                         копирует файл с ядра в конфиг и в нем пагинацию меняем на бутстрап
WithoutUrlPagination                                                          отключаем отображение пагинации в урле
$this->resetPage();                                                           сброс пагинации до первой страницы
php artisan livewire:publish --pagination                                     появятся шаблоны пагинаци, которые мы можем корректировать

<div class="mb-3" wire:ignore>                                                вешаем на тот кусочек вида, который не будет перерендериваться

Загрузка файлов: метод upload зарезервирован (не называть так метод). Не использовать string в свойствах
Валидируем изображения в режиме лайв
#[Validate('nullable|image|extensions:jpg,jpeg,png|max:2048')]         создаем свойство
public $avatar;
use WithFileUploads;    импортируем трейт. Обязательно использовать на компоненте,  если даже логику вынесли!!!!
https://www.youtube.com/watch?v=yEeOwGlAj94&list=PLNvHH49JXUUCkbcg3m3kSmufG4SnirrCv&index=10  22минута видео. Создаем хранилище файлов

#[Layout('components.layouts.main')]                                         смена лейаута и тайтла
#[Title('User Create')]
class UserCreate extends Component

wire:navigate                                                                без перезагрузки страницы в теге
$this->redirect('/', navigate: true);                                        редирект без перезагрузки
$this->redirectRoute('home', navigate: true);                                аналог, но с неймспейсом
<a class="nav-link" wire:current.strict="active" href="#">Home</a>           wire:current подсвечивает активный элемент, strict обрезает концевой слеш

#[Url]                                                                     помогает свойства передавать в параметры строки. Удобно для фильтров
public int $limit = 10;

public function updating($property, $value)                                updating and updated  зарезервированные методы, которые реагируют на любое изменение
{if($property == 'search'){
    $this->resetPage(); };}